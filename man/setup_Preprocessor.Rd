% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/03_S7_Preprocessor.R
\name{setup_Preprocessor}
\alias{setup_Preprocessor}
\title{Setup \code{PreprocessorParameters}}
\usage{
setup_Preprocessor(
  complete_cases = FALSE,
  remove_features_thres = NULL,
  remove_cases_thres = NULL,
  missingness = FALSE,
  impute = FALSE,
  impute_type = c("missRanger", "micePMM", "meanMode"),
  impute_missRanger_params = list(pmm.k = 3, maxiter = 10, num.trees = 500),
  impute_discrete = "get_mode",
  impute_numeric = "mean",
  integer2factor = FALSE,
  integer2numeric = FALSE,
  logical2factor = FALSE,
  logical2numeric = FALSE,
  numeric2factor = FALSE,
  numeric2factor_levels = NULL,
  numeric_cut_n = 0,
  numeric_cut_labels = FALSE,
  numeric_quant_n = 0,
  numeric_quant_NAonly = FALSE,
  len2factor = 0,
  character2factor = FALSE,
  factorNA2missing = FALSE,
  factorNA2missing_level = "missing",
  factor2integer = FALSE,
  factor2integer_startat0 = TRUE,
  scale = FALSE,
  center = scale,
  scale_centers = NULL,
  scale_coefficients = NULL,
  remove_constants = FALSE,
  remove_constants_skip_missing = TRUE,
  remove_features = NULL,
  remove_duplicates = FALSE,
  one_hot = FALSE,
  one_hot_levels = NULL,
  add_date_features = FALSE,
  date_features = c("weekday", "month", "year"),
  add_holidays = FALSE,
  exclude = NULL
)
}
\arguments{
\item{complete_cases}{Logical: If TRUE, only retain complete cases (no missing data).}

\item{remove_features_thres}{Float (0, 1): Remove features with missing
values in >= to this fraction of cases.}

\item{remove_cases_thres}{Float (0, 1): Remove cases with >= to this fraction
of missing features.}

\item{missingness}{Logical: If TRUE, generate new boolean columns for each
feature with missing values, indicating which cases were missing data.}

\item{impute}{Logical: If TRUE, impute missing cases. See \code{impute_discrete} and
\code{impute_numeric}.}

\item{impute_type}{Character: Package to use for imputation.}

\item{impute_missRanger_params}{Named list with elements "pmm.k" and
"maxiter", which are passed to \code{missRanger::missRanger}. \code{pmm.k}
greater than 0 results in predictive mean matching. Default \code{pmm.k = 3}
\code{maxiter = 10} \code{num.trees = 500}. Reduce \code{num.trees} for
faster imputation especially in large datasets. Set \code{pmm.k = 0} to
disable predictive mean matching.}

\item{impute_discrete}{Character: Name of function that returns single value: How to impute
discrete variables for \code{impute_type = "meanMode"}.}

\item{impute_numeric}{Character: Name of function that returns single value: How to impute
continuous variables for \code{impute_type = "meanMode"}.}

\item{integer2factor}{Logical: If TRUE, convert all integers to factors. This includes
\code{bit64::integer64} columns.}

\item{integer2numeric}{Logical: If TRUE, convert all integers to numeric
(will only work if \code{integer2factor = FALSE}). This includes
\code{bit64::integer64} columns.}

\item{logical2factor}{Logical: If TRUE, convert all logical variables to
factors.}

\item{logical2numeric}{Logical: If TRUE, convert all logical variables to
numeric.}

\item{numeric2factor}{Logical: If TRUE, convert all numeric variables to
factors.}

\item{numeric2factor_levels}{Character vector: Optional - will be passed to
\code{levels} arg of \code{factor()} if \code{numeric2factor = TRUE}. For advanced/
specific use cases; need to know unique values of numeric vector(s) and given all
numeric vars have same unique values.}

\item{numeric_cut_n}{Integer: If > 0, convert all numeric variables to factors by
binning using \code{base::cut} with \code{breaks} equal to this number.}

\item{numeric_cut_labels}{Logical: The \code{labels} argument of \link[base:cut]{base::cut}.}

\item{numeric_quant_n}{Integer: If > 0, convert all numeric variables to factors by
binning using \code{base::cut} with \code{breaks} equal to this number of quantiles.
produced using \code{stats::quantile}.}

\item{numeric_quant_NAonly}{Logical: If TRUE, only bin numeric variables with
missing values.}

\item{len2factor}{Integer (>=2): Convert all variables with less
than or equal to this number of unique values to factors.
For example, if binary variables are encoded with 1, 2, you could use
\code{len2factor = 2} to convert them to factors.}

\item{character2factor}{Logical: If TRUE, convert all character variables to
factors.}

\item{factorNA2missing}{Logical: If TRUE, make NA values in factors be of
level \code{factorNA2missing_level}. In many cases this is the preferred way
to handle missing data in categorical variables. Note that since this step
is performed before imputation, you can use this option to handle missing
data in categorical variables and impute numeric variables in the same
\code{preprocess} call.}

\item{factorNA2missing_level}{Character: Name of level if
\code{factorNA2missing = TRUE}.}

\item{factor2integer}{Logical: If TRUE, convert all factors to integers.}

\item{factor2integer_startat0}{Logical: If TRUE, start integer coding at 0.}

\item{scale}{Logical: If TRUE, scale columns of \code{x}.}

\item{center}{Logical: If TRUE, center columns of \code{x}. Note that by
default it is the same as \code{scale}.}

\item{scale_centers}{Named vector: Centering values for each feature.}

\item{scale_coefficients}{Named vector: Scaling values for each feature.}

\item{remove_constants}{Logical: If TRUE, remove constant columns.}

\item{remove_constants_skip_missing}{Logical: If TRUE, skip missing values, before
checking if feature is constant.}

\item{remove_features}{Character vector: Features to remove.}

\item{remove_duplicates}{Logical: If TRUE, remove duplicate cases.}

\item{one_hot}{Logical: If TRUE, convert all factors using one-hot encoding.}

\item{one_hot_levels}{List: Named list of the form "feature_name" = "levels". Used when applying
one-hot encoding to validation or test data using \code{Preprocessor}.}

\item{add_date_features}{Logical: If TRUE, extract date features from date columns.}

\item{date_features}{Character vector: Features to extract from dates.}

\item{add_holidays}{Logical: If TRUE, extract holidays from date columns.}

\item{exclude}{Integer, vector: Exclude these columns from preprocessing.}
}
\value{
\code{PreprocessorParameters} object.
}
\description{
Setup \code{PreprocessorParameters}
}
\author{
EDG
}
