% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/preprocess.R
\name{preprocess}
\alias{preprocess}
\title{Data preprocessing}
\usage{
preprocess(
  x,
  y = NULL,
  completeCases = FALSE,
  removeCases.thres = NULL,
  removeFeatures.thres = NULL,
  missingness = FALSE,
  impute = FALSE,
  impute.type = c("missRanger", "micePMM", "meanMode"),
  impute.missRanger.params = list(pmm.k = 3, maxiter = 10, num.trees = 500),
  impute.discrete = getMode,
  impute.numeric = mean,
  integer2factor = FALSE,
  integer2numeric = FALSE,
  logical2factor = FALSE,
  logical2numeric = FALSE,
  numeric2factor = FALSE,
  numeric2factor.levels = NULL,
  ltn2factor = 0,
  character2factor = FALSE,
  factorNA2missing = FALSE,
  factorNA2missing.level = "missing",
  nonzeroFactors = FALSE,
  scale = FALSE,
  center = FALSE,
  removeConstants = TRUE,
  removeDuplicates = FALSE,
  factorizeThresh = 0,
  oneHot = FALSE,
  exclude = NULL,
  verbose = TRUE,
  parallel.type = ifelse(.Platform$OS.type == "unix", "fork", "psock")
)
}
\arguments{
\item{x}{Input data frame}

\item{completeCases}{Logical: If TRUE, only retain complete cases (no missing data).
Default = FALSE}

\item{removeCases.thres}{Float (0, 1): Remove cases with >= to this fraction of missing features.
Default = NULL}

\item{removeFeatures.thres}{Float (0, 1): Remove features with missing values in >= to this fraction of
cases. Default = NULL}

\item{missingness}{Logical: If TRUE, generate new boolean columns for each feature with missing values, indicating
which cases were missing data. Default = FALSE}

\item{impute}{Logical: If TRUE, impute missing cases. See \code{impute.discrete} and
\code{impute.numeric} for how}

\item{impute.type}{Character: How to impute data: "missRanger" and "missForest" use the packages of the same name to
impute by iterative random forest regression. "rfImpute" uses \code{randomForest::rfImpute} (see its documentation),
"meanMode" will use mean and mode by default or any custom function defined in \code{impute.discrete} and
\code{impute.numeric}. Default = "missRanger" (which is much faster than "missForest").
"missForest" is included for compatibility with older pipelines.}

\item{impute.missRanger.params}{Named list with elements "pmm.k" and "maxiter", which are passed to
\code{missRanger::missRanger}. \code{pmm.k} greater than 0 results in predictive mean matching.
Default \code{pmm.k = 3} \code{maxiter = 10} \code{num.trees = 500}. Reduce \code{num.trees} for
faster imputation especially in large datasets. Set \code{pmm.k = 0} to disable predictive mean
matching
to \code{missForest::missForest}}

\item{impute.discrete}{Function that returns single value: How to impute discrete variables for
\code{impute.type = "meanMode"}. Default = \link{getMode}}

\item{impute.numeric}{Function that returns single value: How to impute continuous variables for
\code{impute.type = "meanMode"}.
Default = \code{mean}}

\item{integer2factor}{Logical: If TRUE, convert all integers to factors}

\item{integer2numeric}{Logical: If TRUE, convert all integers to numeric (will only work
if \code{integer2factor = FALSE})}

\item{logical2factor}{Logical: If TRUE, convert all logical variables to factors}

\item{logical2numeric}{Logical: If TRUE, convert all logical variables to numeric}

\item{numeric2factor}{Logical: If TRUE, convert all numeric variables to factors}

\item{ltn2factor}{Integer (>2): Convert all numeric variables with less than this number of unique
values to factors. Default = NULL. For example, if binary variables are encoded with 1, 2,
you could use \code{ltn2factor = 3} to convert them to factors.}

\item{character2factor}{Logical: If TRUE, convert all character variables to factors}

\item{factorNA2missing}{Logical: If TRUE, make NA values in factors be of level
\code{factorNA2missing.level}. In many cases this is the preferred way to handle missing data in
categorical variables. Note that since this step is performed before imputation, you can use this
option to handle missing data in categorical variables and impute numeric variables in the same
\code{preprocess} call.}

\item{factorNA2missing.level}{Character: Name of level if \code{factorNA2missing = TRUE}.
Default = "missing"}

\item{nonzeroFactors}{Logical: Shift factor values to exclude zeros. Default = FALSE}

\item{scale}{Logical: If TRUE, scale columns of \code{x}}

\item{center}{Logical: If TRUE, center columns of \code{x}}

\item{removeConstants}{Logical: If TRUE, remove constant columns. Default = TRUE}

\item{removeDuplicates}{Logical: If TRUE, remove duplicated cases. Default = FALSE}

\item{oneHot}{Logical: If TRUE, convert all factors using one-hot encoding}

\item{exclude}{Integer, vector: Exclude these columns from all preprocessing. Default = NULL}

\item{verbose}{Logical: If TRUE, write messages to console. Default = TRUE}
}
\description{
Prepare data for analysis and visualization
}
\details{
By default, removes constant features and duplicated cases
(removeConstants = TRUE, removeDuplicates = TRUE), everything else must be specified.

Order of operations (reflected by order of arguments in usage):
\itemize{
\item keep complete cases only
\item remove duplicates
\item remove cases by missingness threshold
\item remove features by missingness threshold
\item integer to factor
\item integer to numeric
\item logical to factor
\item logical to numeric
\item numeric to factor
\item numeric with less than N unique values to factor
\item character to factor
\item factor NA to named level
\item add missingness column
\item impute
\item scale and/or center
\item remove constants
\item one-hot encoding
}
}
\author{
E.D. Gennatas
}
