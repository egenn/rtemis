% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/s_AddTree.R
\name{s_AddTree}
\alias{s_AddTree}
\title{Additive Tree: Tree-Structured Boosting \link{C}}
\usage{
s_AddTree(
  x,
  y = NULL,
  x.test = NULL,
  y.test = NULL,
  x.name = NULL,
  y.name = NULL,
  weights = NULL,
  update = c("exponential", "polynomial"),
  min.update = ifelse(update == "polynomial", 0.035, 1000),
  min.hessian = 0.001,
  min.membership = 1,
  steps.past.min.membership = 0,
  gamma = 0.8,
  max.depth = 30,
  learning.rate = 0.1,
  ifw = TRUE,
  ifw.type = 2,
  upsample = FALSE,
  downsample = FALSE,
  resample.seed = NULL,
  imetrics = TRUE,
  grid.resample.params = setup.resample("kfold", 5),
  metric = "Balanced Accuracy",
  maximize = TRUE,
  rpart.params = NULL,
  match.rules = TRUE,
  print.plot = FALSE,
  plot.fitted = NULL,
  plot.predicted = NULL,
  plot.theme = rtTheme,
  question = NULL,
  verbose = TRUE,
  prune.verbose = FALSE,
  trace = 1,
  grid.verbose = verbose,
  outdir = NULL,
  save.rpart = FALSE,
  save.mod = ifelse(!is.null(outdir), TRUE, FALSE),
  n.cores = rtCores
)
}
\arguments{
\item{x}{Numeric vector or matrix / data frame of features i.e. independent variables}

\item{y}{Numeric vector of outcome, i.e. dependent variable}

\item{x.test}{Numeric vector or matrix / data frame of testing set features
Columns must correspond to columns in \code{x}}

\item{y.test}{Numeric vector of testing set outcome}

\item{x.name}{Character: Name for feature set}

\item{y.name}{Character: Name for outcome}

\item{weights}{Numeric vector: Weights for cases. For classification, \code{weights} takes precedence
over \code{ifw}, therefore set \code{weights = NULL} if using \code{ifw}.
Note: If \code{weight} are provided, \code{ifw} is not used. Leave NULL if setting \code{ifw = TRUE}.}

\item{update}{Character: "exponential" or "polynomial". Type of weight update. Default = "exponential"}

\item{min.update}{Float: Minimum update for gradient step}

\item{min.hessian}{[gS] Float: Minimum second derivative to continue splitting. Default = .001}

\item{min.membership}{Integer: Minimum number of cases in a node. Default = 1}

\item{steps.past.min.membership}{Integer: N steps to make past \code{min.membership} - For testing. Default = 0}

\item{gamma}{[gS] Float: acceleration factor = lambda/(1 + lambda). Default = .8}

\item{max.depth}{[gS] Integer: maximum depth of the tree. Default = 30}

\item{learning.rate}{[gS] learning rate for the Newton Raphson step that updates the function values
of the node}

\item{ifw}{Logical: If TRUE, apply inverse frequency weighting
(for Classification only).
Note: If \code{weights} are provided, \code{ifw} is not used.}

\item{ifw.type}{Integer {0, 1, 2}
1: class.weights as in 0, divided by min(class.weights)
2: class.weights as in 0, divided by max(class.weights)}

\item{upsample}{Logical: If TRUE, upsample cases to balance outcome classes (for Classification only)
Note: upsample will randomly sample with replacement if the length of the majority class is more than double
the length of the class you are upsampling, thereby introducing randomness}

\item{downsample}{Logical: If TRUE, downsample majority class to match size of minority class}

\item{resample.seed}{Integer: If provided, will be used to set the seed during upsampling.
Default = NULL (random seed)}

\item{imetrics}{Logical: If TRUE, save interpretability metrics, i.e. N total nodes in tree and depth, in output. Default = TRUE}

\item{grid.resample.params}{List: Output of \link{setup.resample} defining
grid search parameters.}

\item{metric}{Character: Metric to minimize, or maximize if
\code{maximize = TRUE} during grid search. Default = NULL, which results in
"Balanced Accuracy" for Classification,
"MSE" for Regression, and "Coherence" for Survival Analysis.}

\item{maximize}{Logical: If TRUE, \code{metric} will be maximized if grid
search is run.}

\item{rpart.params}{List: \code{rpart} parameters, passed to \code{rpart::rpart("parms")}}

\item{match.rules}{Logical: If TRUE, match cases to rules to get statistics per node, i.e. what
percent of cases match each rule. If available, these are used by \link{dplot3_addtree} when plotting. Default = TRUE}

\item{print.plot}{Logical: if TRUE, produce plot using \code{mplot3}
Takes precedence over \code{plot.fitted} and \code{plot.predicted}.}

\item{plot.fitted}{Logical: if TRUE, plot True (y) vs Fitted}

\item{plot.predicted}{Logical: if TRUE, plot True (y.test) vs Predicted.
Requires \code{x.test} and \code{y.test}}

\item{plot.theme}{Character: "zero", "dark", "box", "darkbox"}

\item{question}{Character: the question you are attempting to answer with this model, in plain language.}

\item{verbose}{Logical: If TRUE, print summary to screen.}

\item{prune.verbose}{Logical: If TRUE, prune tree.}

\item{trace}{Integer: 0, 1, 2. The higher the number, the more verbose the output.}

\item{grid.verbose}{Logical: Passed to \code{gridSearchLearn}}

\item{outdir}{Path to output directory.
If defined, will save Predicted vs. True plot, if available,
as well as full model output, if \code{save.mod} is TRUE}

\item{save.rpart}{Logical: passed to \code{addtree}}

\item{save.mod}{Logical: If TRUE, save all output to an RDS file in \code{outdir}
\code{save.mod} is TRUE by default if an \code{outdir} is defined. If set to TRUE, and no \code{outdir}
is defined, outdir defaults to \code{paste0("./s.", mod.name)}}

\item{n.cores}{Integer: Number of cores to use.}
}
\value{
Object of class \code{rtMod}
}
\description{
Train an Additive Tree model
}
\details{
This function is for binary classification. The outcome must be a factor with two levels, the first level
is the 'positive' class. Ensure there are no missing values in the data and that variables are either numeric
(including integers) or factors. Use \link{preprocess} as needed to impute and convert characters to factors.

Factor levels should not contain the "/" character (it is used to separate conditions
in the addtree object)

[gS] Indicates that more than one value can be supplied, which will result in grid search using
internal resampling
lambda = gamma/(1 - gamma)
}
\references{
Jose Marcio Luna, Efstathios D Gennatas, Lyle H Ungar, Eric Eaton, Eric S Diffenderfer, Shane T Jensen,
Charles B Simone, Jerome H Friedman, Timothy D Solberg, Gilmer Valdes
Building more accurate decision trees with the additive tree
Proc Natl Acad Sci U S A. 2019 Oct 1;116(40):19887-19893. doi: 10.1073/pnas.1816748116
}
\seealso{
Other Supervised Learning: 
\code{\link{s_AdaBoost}()},
\code{\link{s_BART}()},
\code{\link{s_BRUTO}()},
\code{\link{s_BayesGLM}()},
\code{\link{s_C50}()},
\code{\link{s_CART}()},
\code{\link{s_CTree}()},
\code{\link{s_EVTree}()},
\code{\link{s_GAM}()},
\code{\link{s_GBM}()},
\code{\link{s_GLM}()},
\code{\link{s_GLMNET}()},
\code{\link{s_GLMTree}()},
\code{\link{s_GLS}()},
\code{\link{s_H2ODL}()},
\code{\link{s_H2OGBM}()},
\code{\link{s_H2ORF}()},
\code{\link{s_HAL}()},
\code{\link{s_Isotonic}()},
\code{\link{s_KNN}()},
\code{\link{s_LDA}()},
\code{\link{s_LM}()},
\code{\link{s_LMTree}()},
\code{\link{s_LightCART}()},
\code{\link{s_LightGBM}()},
\code{\link{s_MARS}()},
\code{\link{s_MLRF}()},
\code{\link{s_NBayes}()},
\code{\link{s_NLA}()},
\code{\link{s_NLS}()},
\code{\link{s_NW}()},
\code{\link{s_PPR}()},
\code{\link{s_PolyMARS}()},
\code{\link{s_QDA}()},
\code{\link{s_QRNN}()},
\code{\link{s_RF}()},
\code{\link{s_RFSRC}()},
\code{\link{s_Ranger}()},
\code{\link{s_SDA}()},
\code{\link{s_SGD}()},
\code{\link{s_SPLS}()},
\code{\link{s_SVM}()},
\code{\link{s_TFN}()},
\code{\link{s_XGBoost}()},
\code{\link{s_XRF}()}

Other Tree-based methods: 
\code{\link{s_AdaBoost}()},
\code{\link{s_BART}()},
\code{\link{s_C50}()},
\code{\link{s_CART}()},
\code{\link{s_CTree}()},
\code{\link{s_EVTree}()},
\code{\link{s_GBM}()},
\code{\link{s_GLMTree}()},
\code{\link{s_H2OGBM}()},
\code{\link{s_H2ORF}()},
\code{\link{s_LMTree}()},
\code{\link{s_LightCART}()},
\code{\link{s_LightGBM}()},
\code{\link{s_MLRF}()},
\code{\link{s_RF}()},
\code{\link{s_RFSRC}()},
\code{\link{s_Ranger}()},
\code{\link{s_XGBoost}()},
\code{\link{s_XRF}()}

Other Interpretable models: 
\code{\link{s_C50}()},
\code{\link{s_CART}()},
\code{\link{s_GLM}()},
\code{\link{s_GLMNET}()},
\code{\link{s_GLMTree}()},
\code{\link{s_LMTree}()}
}
\author{
E.D. Gennatas
}
\concept{Interpretable models}
\concept{Supervised Learning}
\concept{Tree-based methods}
